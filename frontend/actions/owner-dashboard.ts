'use server'

import { supabaseAdmin } from "@/lib/supabase-admin"
import { createClient } from "@supabase/supabase-js"

// Use a standard client for verifying tokens if needed, but admin can also getUser(token)
// Actually admin auth.getUser(token) works.

async function getAuthenticatedUser(accessToken: string) {
    const { data: { user }, error } = await supabaseAdmin.auth.getUser(accessToken)
    if (error || !user) return null
    return user
}

async function getCurrentOwner(accessToken: string) {
    const user = await getAuthenticatedUser(accessToken)
    if (!user) return null

    // Find the owner record linked to this user
    const { data: owner } = await supabaseAdmin
        .from('owners')
        .select('*')
        .eq('user_id', user.id)
        .single()

    return owner
}

export async function getOwnerDashboardMetrics(accessToken: string) {
    const owner = await getCurrentOwner(accessToken)
    if (!owner) {
        const user = await getAuthenticatedUser(accessToken)
        if (user) {
            return { error: `Acceso Denegado: El usuario (${user.email}) no está registrado como propietario.` }
        }
        return { error: 'No autorizado / Sesión inválida' }
    }

    try {
        // 1. Get Properties for this owner (via property_owners join)
        const { data: propertyOwners, error: poError } = await supabaseAdmin
            .from('property_owners')
            .select(`
                percentage,
                property:properties (
                    id,
                    name,
                    units (
                        id,
                        status,
                        contracts (
                            id,
                            status,
                            rent_amount,
                            payments (
                                id,
                                amount,
                                status,
                                date
                            )
                        )
                    )
                )
            `)
            .eq('owner_id', owner.id)

        if (poError) throw poError

        // Calculate Metrics
        let totalProperties = 0
        let totalUnits = 0
        let occupiedUnits = 0
        let vacantUnits = 0

        let totalIncomeMonth = 0
        let pendingPaymentsCount = 0
        let recentPayments: any[] = []

        const currentMonth = new Date().getMonth()
        const currentYear = new Date().getFullYear()

        propertyOwners?.forEach((po: any) => {
            const property = po.property
            if (!property) return

            totalProperties++

            property.units?.forEach((unit: any) => {
                totalUnits++
                if (unit.status === 'occupied') occupiedUnits++
                if (unit.status === 'vacant') vacantUnits++

                unit.contracts?.forEach((contract: any) => {
                    // Filter active contracts or relevant metrics

                    contract.payments?.forEach((payment: any) => {
                        const paymentDate = new Date(payment.date)

                        // Yearly/Monthly Income (Approved)
                        if (payment.status === 'approved' &&
                            paymentDate.getMonth() === currentMonth &&
                            paymentDate.getFullYear() === currentYear) {

                            // Adjust for owner percentage?
                            // Usually owners want to see TOTAL generated by property, or their share.
                            // Let's show TOTAL generated by the property units mostly, but maybe label it.
                            // For now, simple summation.
                            totalIncomeMonth += Number(payment.amount)
                        }

                        if (payment.status === 'pending') {
                            pendingPaymentsCount++
                        }

                        // Collect recent payments
                        if (payment.status === 'approved') {
                            recentPayments.push({
                                id: payment.id,
                                propertyName: property.name,
                                unitId: unit.id, // unit name not in default fetch, explicitly need unit name if schema allows or simpler
                                amount: payment.amount,
                                date: payment.date,
                                percentage: po.percentage
                            })
                        }
                    })
                })
            })
        })

        // Sort recent payments
        recentPayments.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())

        return {
            data: {
                ownerName: owner.name,
                totalProperties,
                totalUnits,
                occupiedUnits,
                vacantUnits,
                occupancyRate: totalUnits > 0 ? (occupiedUnits / totalUnits) * 100 : 0,
                totalIncomeMonth,
                pendingPaymentsCount,
                recentPayments: recentPayments.slice(0, 5) // Top 5
            }
        }

    } catch (error: any) {
        console.error("Error fetching owner dashboard data:", error)
        return { error: error.message }
    }
}

export async function getOwnerProperties(accessToken: string) {
    const owner = await getCurrentOwner(accessToken)
    if (!owner) return { error: 'No autorizado' }

    try {
        const { data: propertyOwners, error } = await supabaseAdmin
            .from('property_owners')
            .select(`
                percentage,
                property:properties (
                    *,
                    units (
                        id,
                        name,
                        status,
                        type,
                        contracts (
                            id,
                            status,
                            rent_amount,
                            tenant:tenants(name)
                        )
                    )
                )
            `)
            .eq('owner_id', owner.id)

        if (error) throw error

        const properties = propertyOwners.map((po: any) => ({
            ...po.property,
            ownerPercentage: po.percentage,
            unitsCount: po.property.units.length,
            occupiedCount: po.property.units.filter((u: any) => u.status === 'occupied').length
        }))

        return { data: properties }

    } catch (error: any) {
        return { error: error.message }
    }
}

export async function getOwnerPropertyDetails(propertyId: string, accessToken: string) {
    const owner = await getCurrentOwner(accessToken)
    if (!owner) return { error: 'No autorizado' }

    try {
        // 1. Verify ownership
        const { data: ownership, error: ownerError } = await supabaseAdmin
            .from('property_owners')
            .select('percentage')
            .eq('property_id', propertyId)
            .eq('owner_id', owner.id)
            .single()

        if (ownerError || !ownership) throw new Error("No tiene permisos para ver esta propiedad")

        // 2. Fetch Property Details with Units, Contracts (Active), and Expenses
        const { data: property, error: propError } = await supabaseAdmin
            .from('properties')
            .select(`
                *,
                type:property_types(label),
                units (
                    id,
                    name,
                    status,
                    type,
                    area,
                    default_rent_amount,
                    contracts (
                        id,
                        status,
                        start_date,
                        end_date,
                        rent_amount,
                        tenant:tenants(name, email, phone),
                        payments (
                            id,
                            date,
                            amount,
                            status,
                            concept
                        )
                    ),
                    expenses (
                        id,
                        date,
                        amount,
                        category,
                        description,
                        status
                    )
                ),
                property_expenses:expenses (
                    id,
                    date,
                    amount,
                    category,
                    description,
                    status
                )
            `)
            .eq('id', propertyId)
            .single()

        if (propError) throw propError

        // Process data
        // Filter contracts to show only active or latest?
        // Let's attach the "Current Contract" to unit if exists
        const unitsWithTenant = property.units.map((unit: any) => {
            // Find active contract
            const activeContract = unit.contracts?.find((c: any) => c.status === 'active')
            return {
                ...unit,
                activeContract: activeContract || null
            }
        })

        // Combine expenses (Unit level + Property level)
        // Note: 'property_expenses' is direct link to property. 'units.expenses' is link via unit.
        // We want to show a consolidated list maybe?
        let allExpenses: any[] = []
        if (property.property_expenses) {
            allExpenses = [...allExpenses, ...property.property_expenses.map((e: any) => ({ ...e, unitName: 'General' }))]
        }
        property.units?.forEach((u: any) => {
            if (u.expenses) {
                allExpenses = [...allExpenses, ...u.expenses.map((e: any) => ({ ...e, unitName: u.name }))]
            }
        })

        // Sort expenses by date desc
        allExpenses.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())

        return {
            data: {
                ...property,
                units: unitsWithTenant,
                expenses: allExpenses,
                ownerPercentage: ownership.percentage
            }
        }

    } catch (error: any) {
        console.error("Error fetching property details:", error)
        return { error: error.message }
    }
}
